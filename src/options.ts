import fs from "fs";
import prettier from "prettier";
import * as t from "io-ts";

export async function prettierOptions(path: string): Promise<prettier.Options> {
  const options = await prettier.resolveConfig(path);

  return {
    ...options,
    parser: "typescript",
  };
}

const PartialOptions = t.type({
  uri: t.string,
  database: t.string,
  out: t.string,
  bannerComment: t.array(t.string),
  enableConstEnums: t.boolean,
  ignoreMinAndMaxItems: t.boolean,
  strictIndexSignatures: t.boolean,
  unknownAny: t.boolean,
});

export type Options = t.TypeOf<typeof PartialOptions>;

export const defaultOptions: Options = {
  uri: "mongodb://localhost:27017",
  database: "",
  out: "src/__generated__",
  bannerComment: [
    "/* eslint-disable */",
    "",
    "/**",
    "* This file was automatically generated by bson-schema-to-typescript.",
    "* https://www.npmjs.com/package/bson-schema-to-typescript",
    "*",
    "* Do not modify it by hand. Instead, modify the MongoDB $jsonSchema validator,",
    "* and run bson2ts to regenerate this file.",
    "*/",
  ],
  enableConstEnums: true,
  ignoreMinAndMaxItems: false,
  strictIndexSignatures: false,
  unknownAny: true,
};

function readConfig() {
  const configPath = "./bson2ts.json";

  return fs.existsSync(configPath)
    ? fs.readFileSync(configPath).toString()
    : JSON.stringify({});
}

export function parseConfig(config: string): Options {
  try {
    JSON.parse(config);
  } catch (error) {
    throw new Error(`Invalid configuration`);
  }

  const options = JSON.parse(config) as unknown;

  if (
    typeof options !== "object" ||
    options === null ||
    Array.isArray(options)
  ) {
    throw new Error(`Invalid configuration`);
  }

  const mergedOptions: Options = { ...defaultOptions, ...options };

  if (!PartialOptions.is(mergedOptions)) {
    throw new Error(`Invalid configuration`);
  }

  Object.keys(mergedOptions).forEach((key) => {
    if (!Reflect.has(defaultOptions, key)) {
      throw new Error(`Invalid configuration`);
    }
  });

  return {
    ...mergedOptions,
    uri: expandEnv(mergedOptions.uri),
    database: expandEnv(mergedOptions.database),
  };
}

export function loadConfig(): Options {
  const config = readConfig();

  return parseConfig(config);
}

function getEnv(name: string): string {
  const env = process.env[name];

  if (!env) {
    throw new Error(`${name} environment variable not defined`);
  }

  return env;
}

/**
 * Returns the expanded environment variable if the provided value starts with
 * "$", otherwise returns the provided value as-is.
 */
export function expandEnv(val: string): string {
  return val.startsWith("$") ? getEnv(val.slice(1)) : val;
}
